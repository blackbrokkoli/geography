<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <link href="https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://d3js.org/d3.v3.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://d3js.org/d3-array.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  <script src="./wikiatlas.js"></script>
</head>
<body>
  <style>
    body {
      background: #31242D;
      color: #EFF1F1;
    }
    svg {
      /* border: 1px solid #BBB;  */
    }
    #hook {
      margin:10px 10%;
      padding:20px;
      height:100%;
      clear:both;
    }
    #top{
      margin:10px 10%;
    }
    .country{
      display:none;
      fill:#96C6D8;
      stroke:#555;
    }
    .country-back{
      fill:#31242D;
      stroke:;
    }
    .correct {
      fill:#6985A4;
    }
    .error{
      fill:#6985A4;
      /* fill-opacity: 0.6; */
    }
    .fill {
      fill: #EFF1F1;
    }
    .graticule {
      /* fill: none; */
      /* stroke: #777; */
      stroke-width: .5px;
      stroke-opacity: .5;
    }
    #top .start{
      position: absolute;
      top: 43%;
      left: 45%;
      background: #fff;
      width: auto;
      padding: 4px 10px;
      text-align: center;
      font-size: 140%;
    }
    #options{
      margin-bottom:10px;
    }

  </style>
  <div id="hook"></div>
    <div class="text-5xl font-bold uppercase text-center m-8" id="country"> </div>
  <div id="score"></div>
  <div id="info" class="border rounded p-4">Info</div>

  <script>
    /* ****************************************************** */
    /* INIT************************************************** */
    var width = document.getElementById('hook').offsetWidth-60;
    var height = width / 2;

    var topo,all,tries=0,score=0;

    var projection = d3.geo.equirectangular().translate([0, 0]).scale(width / 2 / Math.PI);

    var path = d3.geo.path().projection(projection);

    var graticule = d3.geo.graticule();

    /* ****************************************************** */
    /* SVG ************************************************** */
    var svg = d3.select("#hook").append("svg")
    .attr("width", width)
    .attr("height", height);

    var outterg = svg.append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    var g = outterg.append("g").attr("id", "innerg");

    g.append("defs").append("path")
    .datum({type: "Sphere"})
    .attr("id", "sphere")
    .attr("d", path);

    g.append("use")
    .attr("class", "stroke")
    .attr("xlink:href", "#sphere");

    g.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");

    g.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);

    /* ****************************************************** */
    /* GIS data injection *********************************** */
    d3.json("./world.json", function(error, world) {


      topo = topojson.feature(world, world.objects.countries).features;
      var neighbors = topojson.neighbors(world.objects.countries.geometries);

      //filter and place borders into topo
      topo = topo.filter(function(f,i){
        if(path.area(f)>10){
          var b = neighbors[i];
          var t = 'Nearby...  ';
          f.properties.countryName = "Test"
          if(b.length>0){
            b.forEach(function(g){
              t = t + topo[g].properties.name+', ';
            });
            f.properties.borders = t.substr(0,t.length-2);
          } else {
            f.properties.borders = 'No nearby countries';
          }
          return f;
        }
      });

      console.log("Topo 0", topo[0].properties)

      //lets shuffle topo so that it shows different countries on each reload
      d3.shuffle(topo);


      // Names are lost here
      var country = d3.select("#innerg").selectAll(".country").data(topo);

      console.log("country 0", country[0])

      //ofsets (useless !)
      var offsetL = document.getElementById('hook').offsetLeft+30;
      var offsetT =document.getElementById('hook').offsetTop-30;

      d3.select("#innerg").insert("path")
      .datum(topojson.feature(world, world.objects.countries))
      .attr("class", "country-back")
      .attr("d", path);

      country.enter().insert("path")
      .attr("class", "country")
      .attr("d", path)
      .attr("id", function(d,i) { return 'b'+d.id; })
      .attr("title", function(d,i) { return d.properties.id; })
      .style("stroke", "#111")
      .attr("transform", function(d,i) {
        var cx = Number(-1*path.centroid(d)[0]);
        var cy = Number(-1*path.centroid(d)[1]);
        var coord = [cx,cy];
        return "translate(" + coord + ")"
      })
      .attr("x", function(d,i) {
        var cx = Number(-1*path.centroid(d)[0]);
        return cx;
      })
      .attr("y", function(d,i) {
        var cy = Number(-1*path.centroid(d)[1]);
        return cy;
      })
      .call(drag);

      //all used to keep track
      // what?
      all = d3.selectAll(".country")[0];
      console.log(all)
      d3.select("#info").text("World Map");

      //start
      go();

    });



    /* ****************************************************** */
    /* GAME FUNCTION **************************************** */
    /* Start ************************************************ */
    function go(){
      d3.select("#info").attr("class","start");
      var missed = topo.length - all.length - score;
      d3.select("#score").text("Score: "+score+"/"+topo.length+" | Missed: "+missed);

      if(all.length>0){
        var obj = d3.select(all.shift());
        // console.log("Generated Obj", obj)
        console.log("Generated Obj Prop", obj[0][0].__data__.properties.name )
        d3.select("#country").text(obj[0][0].__data__.properties.name)
        obj.style("display","block");
        // console.log(obj.attr("title"));
        d3.select("#info").text(obj.attr("title"));
        window.setTimeout(function(){
          d3.select("#info").attr("class","");
        }, 1500);
      } else {
        d3.select("#info").text("All Done. Restart to try again.");
        d3.select(".country-back").transition().duration(1500).style("fill", function(){
          return "#666";
        });
      }
    }

    /* Borders or not *************************************** */
    // d3.select("#borders").on("click",function(){
    //   // if(this.checked){ d3.select(".country-back").style("stroke","#ddd"); }
    //   d3.select(".country-back").style("stroke","#e3553d");
    // });



    /* ****************************************************** */
    /* DRAG & DROP ****************************************** */
    var drag = d3.behavior.drag()
    .on("drag", dragmove)
    .on("dragstart", dragstart)
    .on("dragend", dragend);

    function dragstart(d) {
      //d3.event.sourceEvent.stopPropagation(); // silence other listeners
      d.x = Number(d3.select(this).attr("x"));
      d.y = Number(d3.select(this).attr("y"));
    }

    function dragmove(d) {
      //only if its new country
      if(d3.select('#b'+d.id).attr("class") == "country"){
        console.log(d3.select('#b'+d.id))
        d.x += d3.event.dx;
        d.y += d3.event.dy;
        d3.select(this).attr("transform", function(d,i){
          return "translate(" + [ d.x,d.y ] + ")"
        });
      }
    }

    function dragend(d) {
      //only if its new country
      if(d3.select('#b'+d.id).attr("class") == "country"){

        //snap to position if you are 10 pixels or closer
        if(d.x > -10 && d.x < 10 && d.y > -10 && d.y < 10 ){
          tries = 0; score++;
          d3.select(this)
          .attr("class","correct")
          .attr("transform", function(d,i){ return "translate([0,0])"; });
          go(); // go next

        } else { tries++; /* wrong ********************** */
          if(tries == 1){ // move shape back to Null Island.
            d3.select("#info").text(d.properties.borders.split(",").slice(0,3));
            //put back in the middle!
            var cx = Number(-1*path.centroid(d)[0]);
            var cy = Number(-1*path.centroid(d)[1]);
            var coord = [cx,cy];
            d3.select(this).transition().duration(500).attr("transform", function(d,i){
              return "translate(" + coord + ")"
            });

          } else { //wrong again, move element to correct position and mark red!
            d3.select(this).transition().duration(500).attr("class","error").attr("transform", function(d,i){
              return "translate([0,0])";
            });
            tries = 0;
            go();//go to next!
          }
        }
      }
    }
  </script>
</body>
</html>
